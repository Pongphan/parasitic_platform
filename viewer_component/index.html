<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    body { margin:0; padding:0; background:transparent; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    .wrap { position:relative; user-select:none; }
    canvas {
      border-radius:10px;
      background:#0b1220;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
      cursor:grab;
      display:block;
    }
    canvas:active { cursor:grabbing; }

    .hint {
      position:absolute; left:10px; bottom:10px;
      padding:6px 10px; font-size:12px;
      color:rgba(255,255,255,.85);
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      backdrop-filter:blur(6px);
      pointer-events:none;
    }

    .btn {
      position:absolute; right:10px; top:10px;
      padding:8px 12px; font-size:12px; font-weight:600;
      color:white; background:rgba(56,189,248,.25);
      border:1px solid rgba(56,189,248,.35);
      border-radius:999px;
      backdrop-filter:blur(6px);
      cursor:pointer;
    }
    .btn:hover { background:rgba(56,189,248,.32); }
    .btn:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="cv"></canvas>
    <div class="hint">Wheel = Zoom â€¢ Drag = Pan</div>
    <button id="calcBtn" class="btn">Calculate</button>
  </div>

<script>
  // ---- minimal Streamlit component protocol (no React) ----
  function sendMessage(type, data){
    const out = Object.assign({ isStreamlitMessage:true, type:type }, data);
    window.parent.postMessage(out, "*");
  }
  function componentReady(){ sendMessage("streamlit:componentReady", { apiVersion: 1 }); }
  function setFrameHeight(h){ sendMessage("streamlit:setFrameHeight", { height:h }); }
  function setComponentValue(obj){
    // Send only on Calculate click to trigger exactly 1 rerun
    sendMessage("streamlit:setComponentValue", { value: obj, dataType: "json" });
  }

  // Unique token generator: timestamp + random
  function makeCalcToken(){
    // Date.now() for ms + random for uniqueness even in same ms
    const ts = Date.now().toString(36);
    const rnd = Math.random().toString(36).slice(2, 10);
    return ts + "-" + rnd;
  }

  const canvas = document.getElementById("cv");
  const ctx = canvas.getContext("2d");
  const img = new Image();

  // Frontend-only state (NO sending during zoom/pan)
  let vp = 600;
  let zoom = 1.0, panX = 0.0, panY = 0.0;
  let dragging = false, lastX = 0, lastY = 0;

  function resizeCanvas(newVp){
    vp = newVp;
    canvas.width = vp; canvas.height = vp;
    canvas.style.width = vp + "px";
    canvas.style.height = vp + "px";
    document.querySelector(".wrap").style.width = vp + "px";
    document.querySelector(".wrap").style.height = vp + "px";
    setFrameHeight(vp + 22);
  }

  function draw(){
    ctx.clearRect(0,0,vp,vp);
    ctx.fillStyle = "#0b1220";
    ctx.fillRect(0,0,vp,vp);

    if(!img.complete){
      requestAnimationFrame(draw);
      return;
    }

    const w0 = img.naturalWidth, h0 = img.naturalHeight;
    const baseScale = Math.min(vp / w0, vp / h0);
    const scale = baseScale * zoom;

    const cx = vp/2, cy = vp/2;
    const dw = w0 * scale, dh = h0 * scale;
    const dx = cx - dw/2 + panX;
    const dy = cy - dh/2 + panY;

    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(img, dx, dy, dw, dh);

    // 3x3 grid
    const step = vp/3;
    ctx.save();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(255, 120, 120, 0.55)";
    for(let i=1;i<=2;i++){
      const p = step*i;
      ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,vp); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(vp,p); ctx.stroke();
    }
    ctx.restore();

    // center cell overlay
    ctx.save();
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(120, 200, 255, 0.9)";
    ctx.fillStyle = "rgba(120, 200, 255, 0.10)";
    ctx.beginPath(); ctx.rect(step,step,step,step);
    ctx.fill(); ctx.stroke();
    ctx.restore();

    requestAnimationFrame(draw);
  }

  // Zoom about mouse position (NO sending)
  function onWheel(e){
    e.preventDefault();
    if(!img.complete) return;

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const w0 = img.naturalWidth, h0 = img.naturalHeight;
    const baseScale = Math.min(vp / w0, vp / h0);
    const oldScale = baseScale * zoom;

    const cx = vp/2, cy = vp/2;
    const ix = (mx - cx - panX) / oldScale + (w0/2);
    const iy = (my - cy - panY) / oldScale + (h0/2);

    const factor = (e.deltaY < 0) ? 1.08 : 0.92;
    zoom = Math.max(0.15, Math.min(12.0, zoom * factor));

    const newScale = baseScale * zoom;
    panX = mx - cx - (ix - (w0/2)) * newScale;
    panY = my - cy - (iy - (h0/2)) * newScale;
  }

  function onDown(e){
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
    canvas.setPointerCapture(e.pointerId);
  }
  function onMove(e){
    if(!dragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX; lastY = e.clientY;
    panX += dx; panY += dy;
  }
  function onUp(e){ dragging = false; }

  canvas.addEventListener("wheel", onWheel, { passive:false });
  canvas.addEventListener("pointerdown", onDown);
  canvas.addEventListener("pointermove", onMove);
  canvas.addEventListener("pointerup", onUp);
  canvas.addEventListener("pointercancel", onUp);

  // Calculate button: SEND ONCE -> triggers exactly 1 rerun
  document.getElementById("calcBtn").addEventListener("click", () => {
    const token = makeCalcToken();
    setComponentValue({
      action: "calculate",
      calc_token: token,
      zoom: zoom,
      panX: panX,
      panY: panY,
      viewport: vp
    });
  });

  // Receive args from Python (render)
  function onRender(event){
    if(event.data.type !== "streamlit:render") return;
    const args = event.data.args || {};

    const newVp = Number(args.viewport || 600);
    if(newVp !== vp) resizeCanvas(newVp);

    // init from Python only (first load or python reset)
    zoom = Number(args.init_zoom ?? zoom);
    panX = Number(args.init_panX ?? panX);
    panY = Number(args.init_panY ?? panY);

    const b64 = args.image_b64 || "";
    img.src = "data:image/png;base64," + b64;
  }

  window.addEventListener("message", onRender);

  // init
  componentReady();
  resizeCanvas(600);
  requestAnimationFrame(draw);
</script>
</body>
</html>
